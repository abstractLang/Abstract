###    ABSTRACT STANDARD LIBRARY SCRIPT    ###

namespace Types {

    @public @comptime func type typeOf(anytype value) {}

    @public @comptime func i32 sizeOf(type t) {}
    @public @comptime func i32 sizeOf(anytype value) {}

    @public @comptime func i32 bitSizeOf(type t) {}
    @public @comptime func i32 bitSizeOf(anytype value) {}

    # Primitive and base types 

    @defineGlobal("type") @public @abstract struct Type {}
    @defineGlobal("anytype") @public @abstract struct AnyType {}
    @align(0) @defineGlobal("opaque") @public @abstract struct Opaque {}

    @public @align(align)
    struct Integer(bool signed, ComptimeInteger align) : (align > 0 and align <= 256) {

        @overrideOperator("==")
        @public @static func bool isEquals(Integer a, Integer b) {

        }
        @overrideOperator("!=")
        @public @static func bool isUnequals(Integer a, Integer b) {

        }
        @overrideOperator("<")
        @public @static func bool isLesser(Integer a, Integer b) {

        }
        @overrideOperator(">")
        @public @static func bool isGreater(Integer a, Integer b) {
            
        }
        @overrideOperator("<=")
        @public @static func bool isLesserEquals(Integer a, Integer b)
        @overrideOperator(">=")
        @public @static func bool isGreaterEquals(Integer a, Integer b)

        # TODO other integer binary operations

        @public @static func []byte getBytes()
        @public @static func T fromBytes(type T, [align]byte bytes)
    }

    @align(32) @defineGlobal(["f32", "float"]) @public @final struct Single {}
    @align(64) @defineGlobal(["f64", "double"]) @public @final struct Double {}

    @align(1) @defineGlobal("bool") @public @valueOnly @final struct Boolean {}

    @defineGlobal("string") @public @valueOnly @final struct String {

        @explicitConvert @public @static func i8 parse_i8(string value)
        @explicitConvert @public @static func i16 parse_i16(string value)
        @explicitConvert @public @static func i32 parse_i32(string value)
        @explicitConvert @public @static func i64 parse_i64(string value)
        @explicitConvert @public @static func i128 parse_i128(string value)

        @explicitConvert @public @static func u8 parse_u8(string value)
        @explicitConvert @public @static func u16 parse_u16(string value)
        @explicitConvert @public @static func u32 parse_u32(string value)
        @explicitConvert @public @static func u64 parse_u64(string value)
        @explicitConvert @public @static func u128 parse_u128(string value)
        
        @overrideOperator("+")
        @externInterface @public @static func string concatenate(string left, Std.Compilation.Types.ComptimeString right)
        @overrideOperator("+")
        @externInterface @public @static func string concatenate(string left, string right)
        @overrideOperator("+")
        @externInterface @public @static func string concatenate(string base, char character)
        @overrideOperator("+")
        @externInterface @public @static func string concatenate(string base, []char characters)
        # remember also Std.Compilation.ComptimeString.concatenate functions
        
    }

    @align(32) @defineGlobal("char") @public @valueOnly @final struct Character {}

    @defineGlobal("void") @public @abstract @final struct Void {}
    @defineGlobal("noreturn") @public @abstract @final struct NoReturn {}

    # Type wrappers
    @public @final struct Nullable(type T) {}
    @public @final struct Failable(type T) {}


    namespace Collections {

        @public @final struct Array(type ElementT) {
            
            @indexerGetter @public func ElementT get(i32 i)
            @indexerSetter @public func void set(i32 i, ElementT value)
            @getter("Length") @public func i32 getLength()

        }

        @public @final struct List(type ElementT) {
            
            @indexerGetter @public func ElementT get(i32 i)
            @indexerSetter @public func void set(i32 i, ElementT value)
            @getter("Count") @public func i32 getCount()

        }

        @public @interface struct IDictionary(type TKey, type TValue) {

            @indexerGetter @public func TValue get(TKey key)
            @indexerSetter @public func void set(TKey key, TValue value)
            @getter("Count") @public func i32 getCount()

        }

    }

    namespace Static {

        @public @valueOnly @readonly @final struct Slice(type ElementT) {

            #FIXME make pointers works
            #@public @readonly let *ElementT ptr;
            @public @readonly let uptr len;

            @indexerGetter @public func ElementT get(i32 i)
            @indexerSetter @public func void set(i32 i, ElementT value)

        }

        @public @valueOnly @final struct StringBuffer(uptr bufferLength) {}
        @public @valueOnly @final struct StringSpan {}

    }

}
